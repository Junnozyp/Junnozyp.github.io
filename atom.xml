<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Junno&#39;s Blog</title>
  
  <subtitle>路漫漫其修远兮</subtitle>
  <link href="https://junno_code_blog.gitee.io/junno.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://junno_code_blog.gitee.io/junno.gitee.io/"/>
  <updated>2021-01-21T07:20:56.805Z</updated>
  <id>https://junno_code_blog.gitee.io/junno.gitee.io/</id>
  
  <author>
    <name>Junno</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>test_02.md</title>
    <link href="https://junno_code_blog.gitee.io/junno.gitee.io/2021/01/21/test-02-md/"/>
    <id>https://junno_code_blog.gitee.io/junno.gitee.io/2021/01/21/test-02-md/</id>
    <published>2021-01-21T07:08:37.000Z</published>
    <updated>2021-01-21T07:20:56.805Z</updated>
    
    <content type="html"><![CDATA[\begin{align}X(k) &= \sum_{n=0}^{N-1}x(n)W_N^{nk}\\&= \sum_{n=0}^{\frac{N}{2}-1}x(n)W_N^{nk}+\sum_{n=\frac{N}{2}}^{N-1}x(n)W_N^{nk}\\&= \sum_{n=0}^{\frac{N}{2}-1}x(n)W_N^{nk}+\sum_{n=0}^{\frac{N}{2}-1}x(n+\frac{N}{2})W_N^{(n+\frac{N}{2})k}\\&= \sum_{n=0}^{\frac{N}{2}-1}[x(n)+x(n+\frac{N}{2})W_N^{\frac{Nk}{2}}  ]\cdot W_N^{nk}\,\, k=0,1,...N-1\\\end{align}]]></content>
    
    
      
      
    <summary type="html">\begin{align}
X(k) &amp;= \sum_{n=0}^{N-1}x(n)W_N^{nk}\\
&amp;= \sum_{n=0}^{\frac{N}{2}-1}x(n)W_N^{nk}+\sum_{n=\frac{N}{2}}^{N-1}x(n)W_N^{nk}\\
&amp;= \</summary>
      
    
    
    
    
    <category term="测试用" scheme="https://junno_code_blog.gitee.io/junno.gitee.io/tags/%E6%B5%8B%E8%AF%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>最短路径之Bellman-Ford算法</title>
    <link href="https://junno_code_blog.gitee.io/junno.gitee.io/2021/01/20/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>https://junno_code_blog.gitee.io/junno.gitee.io/2021/01/20/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</id>
    <published>2021-01-20T06:48:00.000Z</published>
    <updated>2021-01-20T09:42:13.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="算法讲解"><a class="markdownIt-Anchor" href="#算法讲解"></a> 算法讲解</h1><p>大家好吖，布谷布谷又来了，dddd</p><p>今天我们来讲讲图搜索最短路径，这里的最短路径包含了从一个节点到达另一个节点需要考虑之间的距离或者时间消耗，即从起点到达终点所需的时间（或者其他形式的消耗）最少，不同于我们之前提到的迷宫搜索类最短路径——通路上的节点数量更少（即假设节点间的距离都是1）。</p><p><img src="https://i.loli.net/2021/01/20/8n1jRGU9bmdNX67.jpg" alt="" /></p><a id="more"></a><p>如下面这张图所示：</p><img src="D:\Junno\Wechat\最短路径搜索\IMG_0551.jpg" alt="IMG_0551" style="zoom: 33%;" /><p>这个时候我们好像需要去遍历图上的节点，常规BFS搜索得到的最短路径不一定是耗时最少的。</p><p>这里我们介绍经典的单源最短路径搜索算法——狄克斯特拉算法（Dijkstra’s algorithm）。单源的意思是说它可以得到指定的一个起点到达其他所有节点的最短距离。</p><p>本质上它是一个循环优化算法，在每个循环里，它完成下面的几个步骤:</p><ol><li>找到当前已知距离起点最短的节点，即可以最快到达的点</li><li>通过与该点连接的其他节点更新周围节点的距离开销，即起点到达这些周围节点的距离</li></ol><p>以上面的图为例，我们来用图表示一下简单的算法流程：</p><img src="D:\Junno\Wechat\最短路径搜索\IMG_0556.jpg" alt="IMG_0552" style="zoom:33%;" /><p>首先最先知道的最短节点是起点本身，一开始我们要设置所有点之间都是无穷远，然后用已知的边来更新这些值，不过这里我给到的图示所有的边权重都有给出。从起点M开始，找到了A，B，N，并更新权重。</p><img src="D:\Junno\Wechat\最短路径搜索\IMG_0554.jpg" alt="IMG_0554" style="zoom: 25%;" /><p>第二次循环开始，找到距离起点最近的点为B后，开始找和B相连的其他节点，记住这些节点不能是之前循环标记过的最近点，因为之前循环确定的最近点对这一轮更新其到起点的距离没有意义，它已经是最近的了。</p><p>我们可以看到符合条件的有A和N，接下来更新它们到起点的距离值。发现MB+BA&lt; MA，即有更近的路可以从起点到达A点，所以更新MA的值，同样的更新MN的值。</p><img src="D:\Junno\Wechat\最短路径搜索\IMG_0555.jpg" alt="IMG_0555" style="zoom:25%;" /><p>第三次循环距离起点最近的点为A，找到与A相连的且还没被标记过的节点，只有N，但是MA+AN=10&gt;MN=8，所以不更新MN的距离值。下一次循环到达终点后即可退出，所以最终起点到达所有其他节点的最短距离都可以得到，也就包括起点到终点。</p><p><img src="D:%5CJunno%5CWechat%5C%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%90%9C%E7%B4%A2%5C19c6650082b162ae8cc9665f967b69f8.jpeg" alt="" /></p><h1 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h1><p>我们来看代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Dijkstra</span>(<span class="params">directed=<span class="literal">False</span></span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Functions: Implementation of Dijkstra using Python</span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">directed: whether the graph is directed or not</span></span><br><span class="line"><span class="string">return:</span></span><br><span class="line"><span class="string">None</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># init distance</span></span><br><span class="line">limit = <span class="number">10000</span></span><br><span class="line"><span class="comment"># number of nodes, number of links, start_index, end_index</span></span><br><span class="line">N, K, s, e = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line"><span class="comment"># graph mat</span></span><br><span class="line">ad_mat = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"><span class="comment"># distance to start_node</span></span><br><span class="line">Dis = [limit <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"><span class="comment"># tags array</span></span><br><span class="line">vis = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"><span class="comment"># use links to fresh graph mat</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(K):</span><br><span class="line">u, v, w = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">ad_mat[u][v] = w</span><br><span class="line"><span class="keyword">if</span> directed == <span class="literal">False</span>:</span><br><span class="line">ad_mat[v][u] = w</span><br><span class="line"><span class="comment"># init distance of start_node</span></span><br><span class="line">Dis[s] = <span class="number">0</span></span><br><span class="line">    <span class="comment"># core logic</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        <span class="comment"># select nodes with shortest distance to start from unchecked nodes</span></span><br><span class="line">min_ind = Dis.index(<span class="built_in">min</span>([Dis[k] <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Dis)) <span class="keyword">if</span> vis[k] == <span class="number">0</span>]))</span><br><span class="line"><span class="comment"># sign the node</span></span><br><span class="line">vis[min_ind] = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="comment"># fresh distance from start_node to adjacent nodes</span></span><br><span class="line"><span class="comment"># unchecked, exist links, shorter then original dis</span></span><br><span class="line"><span class="keyword">if</span> vis[j] == <span class="number">0</span> \</span><br><span class="line"><span class="keyword">and</span> ad_mat[min_ind][j] != <span class="number">0</span> \</span><br><span class="line"><span class="keyword">and</span> Dis[j] &gt; (Dis[min_ind]+ad_mat[min_ind][j]):</span><br><span class="line">Dis[j] = Dis[min_ind]+ad_mat[min_ind][j]</span><br><span class="line">print(<span class="string">&#x27;Shortest distance from s to e: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(Dis[e]))</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>代码细节讲解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min_ind = Dis.index(<span class="built_in">min</span>([Dis[k] <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Dis)) <span class="keyword">if</span> vis[k] == <span class="number">0</span>]))</span><br></pre></td></tr></table></figure><p>这一句是从所以没有被之前的循环标记成最近点的节点中找到距离起点距离最近的一个节点的索引。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> vis[j] == <span class="number">0</span> \</span><br><span class="line"><span class="keyword">and</span> ad_mat[min_ind][j] != <span class="number">0</span> \</span><br><span class="line"><span class="keyword">and</span> Dis[j] &gt; (Dis[min_ind]+ad_mat[min_ind][j]):</span><br><span class="line">Dis[j] = Dis[min_ind]+ad_mat[min_ind][j]</span><br></pre></td></tr></table></figure><p>更新距离（也叫松弛过程）的核心步骤，找到本次循环的最近点A后，从其邻接节点中找到未被标记过的（如果已被标记过，说明已是最近点且更新过周围节点），存在与A的通路link，以及起点到A与A到该节点的距离和小于当前起点到达该节点的距离的节点，然后更新起点到该点的距离值。</p><p>通过代码介绍，我们可以发现给出的实现的时间复杂度为O(n^2)</p><p>我们来跑一下测试样例：</p><img src="D:\Junno\Wechat\最短路径搜索\IMG_0559.jpg" alt="IMG_0559" style="zoom:33%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Dijkstra(directed=<span class="literal">False</span>)</span><br><span class="line"><span class="number">7</span> <span class="number">9</span> <span class="number">0</span> <span class="number">6</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">12</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">14</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">8</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">10</span></span><br><span class="line"><span class="number">6</span> <span class="number">1</span> <span class="number">7</span></span><br><span class="line">Shortest distance <span class="keyword">from</span> s to e: <span class="number">16</span></span><br><span class="line">Time used: <span class="number">0.01053</span>s</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Dijkstra(directed=<span class="literal">True</span>)</span><br><span class="line"><span class="number">7</span> <span class="number">9</span> <span class="number">0</span> <span class="number">6</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">12</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">14</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">8</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">10</span></span><br><span class="line"><span class="number">6</span> <span class="number">1</span> <span class="number">7</span></span><br><span class="line">Shortest distance <span class="keyword">from</span> s to e: <span class="number">32</span></span><br><span class="line">Time used: <span class="number">0.01255</span>s</span><br></pre></td></tr></table></figure><p>上述的Dijkstra算法是有向图和无向图均可适用的，接下来我们画出两种情况下的最短路径：</p><img src="D:\Junno\Wechat\最短路径搜索\IMG_0558.jpg" alt="IMG_0558" style="zoom:33%;" /><p>​无向图（紫色），有向图（绿色）</p><h1 id="bfs实现"><a class="markdownIt-Anchor" href="#bfs实现"></a> BFS实现</h1><p>接下来我们来利用BFS的思想结合优先队列来实现Dijkstra算法，通过我们上面的讲解，我们可以发现，每次循环都是要找出距离起点最近的且还没被标记的点，可以把这个过程抽象成BFS里的找最短路。但是由于加入到队列里的节点无序，所以要借助优先队列来进行排序操作，定义一个可以进行比较的对象。</p><p>这样我们通过BFS每次到达的就是距离起点最近的点，然后再进行松弛操作，会减少很多比较过程，从整体上看，每条边都只被检查过一次。</p><img src="D:\Junno\Wechat\最短路径搜索\54ba22fb346e14cd24a138192ed7a1f6.jpeg" style="zoom:50%;" /><p>首先我们要定义可比较队列对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># comparable object definition</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">compare_obj</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, s, dis</span>):</span></span><br><span class="line">self.s = s <span class="comment"># node_index</span></span><br><span class="line">self.dis = dis <span class="comment"># distance from start node to this</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__lt__</span>(<span class="params">self, other</span>):</span></span><br><span class="line"><span class="keyword">return</span> self.dis &lt; other.dis</span><br></pre></td></tr></table></figure><p>一些数组和临时变量的设置与之前保持一致，加入一个G数组，用来记录每个节点相邻节点的数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用BFS结合优先队列实现Dijkstra</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BFS_Dijkstra</span>(<span class="params">directed=<span class="literal">False</span></span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Functions: Implementation of Dijkstra using BFS and PriorityQueue</span></span><br><span class="line"><span class="string">Args:</span></span><br><span class="line"><span class="string">directed: whether the graph is directed or not</span></span><br><span class="line"><span class="string">return:</span></span><br><span class="line"><span class="string">None</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># comparable object definition</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">compare_obj</span>:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, s, dis</span>):</span></span><br><span class="line">self.s = s</span><br><span class="line">self.dis = dis</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__lt__</span>(<span class="params">self, other</span>):</span></span><br><span class="line"><span class="keyword">return</span> self.dis &lt; other.dis</span><br><span class="line">        </span><br><span class="line"><span class="comment"># init distance</span></span><br><span class="line">limit = <span class="number">10000</span></span><br><span class="line"><span class="comment"># number of nodes, number of links, start_index, end_index</span></span><br><span class="line">N, K, s, e = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">start = time.time()</span><br><span class="line"><span class="comment"># graph mat</span></span><br><span class="line">ad_mat = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"><span class="comment"># distance to start_node</span></span><br><span class="line">Dis = [limit <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"><span class="comment"># tags array</span></span><br><span class="line">vis = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"><span class="comment"># number of adjacent nodes of one node</span></span><br><span class="line">G = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)]</span><br><span class="line"><span class="comment"># use links to fresh graph mat</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(K):</span><br><span class="line">u, v, w = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">ad_mat[u][v] = w</span><br><span class="line">G[u].append(v)</span><br><span class="line"><span class="keyword">if</span> directed == <span class="literal">False</span>:</span><br><span class="line">ad_mat[v][u] = w</span><br><span class="line">G[v].append(u)</span><br><span class="line">            </span><br><span class="line"><span class="comment"># init distance of start_node</span></span><br><span class="line">Dis[s] = <span class="number">0</span></span><br><span class="line">    <span class="comment"># BFS with Priority Queue</span></span><br><span class="line">Q = PriorityQueue()</span><br><span class="line">Q.put(compare_obj(s, Dis[s]))</span><br><span class="line"><span class="keyword">while</span> Q.qsize() != <span class="number">0</span>:</span><br><span class="line">node = Q.get_nowait()</span><br><span class="line">s, dis = node.s, node.dis</span><br><span class="line"><span class="comment"># if check, continue</span></span><br><span class="line"><span class="keyword">if</span> vis[s]:</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line"><span class="comment"># sign the node</span></span><br><span class="line">vis[s] = <span class="literal">True</span></span><br><span class="line"><span class="comment"># fresh distance</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(G[s])):</span><br><span class="line">    ad_node = G[s][i]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> vis[ad_node] <span class="keyword">and</span> Dis[ad_node] &gt; (ad_mat[s][ad_node]+Dis[s]):</span><br><span class="line">    Dis[ad_node] = ad_mat[s][ad_node]+Dis[s]</span><br><span class="line">    Q.put_nowait(compare_obj(ad_node, Dis[ad_node]))</span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;Shortest distance from s to e: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(Dis[e]))</span><br><span class="line">print(<span class="string">&#x27;Time used: &#123;:.5f&#125;s&#x27;</span>.<span class="built_in">format</span>(time.time()-start))</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>我们来看看测试结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>BFS_Dijkstra(<span class="literal">True</span>)</span><br><span class="line"><span class="number">7</span> <span class="number">9</span> <span class="number">0</span> <span class="number">6</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">12</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">14</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">8</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">10</span></span><br><span class="line"><span class="number">6</span> <span class="number">1</span> <span class="number">7</span></span><br><span class="line">Shortest distance <span class="keyword">from</span> s to e: <span class="number">32</span></span><br><span class="line">Time used: <span class="number">0.00573</span>s</span><br></pre></td></tr></table></figure><p>可以看到BFS实现的Dijkstra算法的运行时间比for循环实现在所给例子上的时间快了一倍。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;算法讲解&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#算法讲解&quot;&gt;&lt;/a&gt; 算法讲解&lt;/h1&gt;
&lt;p&gt;大家好吖，布谷布谷又来了，dddd&lt;/p&gt;
&lt;p&gt;今天我们来讲讲图搜索最短路径，这里的最短路径包含了从一个节点到达另一个节点需要考虑之间的距离或者时间消耗，即从起点到达终点所需的时间（或者其他形式的消耗）最少，不同于我们之前提到的迷宫搜索类最短路径——通路上的节点数量更少（即假设节点间的距离都是1）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/20/8n1jRGU9bmdNX67.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</summary>
    
    
    
    
    <category term="最短路径" scheme="https://junno_code_blog.gitee.io/junno.gitee.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
    <category term="Python" scheme="https://junno_code_blog.gitee.io/junno.gitee.io/tags/Python/"/>
    
    <category term="Algorithm" scheme="https://junno_code_blog.gitee.io/junno.gitee.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://junno_code_blog.gitee.io/junno.gitee.io/2021/01/20/hello-world/"/>
    <id>https://junno_code_blog.gitee.io/junno.gitee.io/2021/01/20/hello-world/</id>
    <published>2021-01-20T03:19:21.377Z</published>
    <updated>2021-01-20T03:19:21.378Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>测试用</title>
    <link href="https://junno_code_blog.gitee.io/junno.gitee.io/2012/12/19/my-first-blog/"/>
    <id>https://junno_code_blog.gitee.io/junno.gitee.io/2012/12/19/my-first-blog/</id>
    <published>2012-12-19T06:48:00.000Z</published>
    <updated>2021-01-21T07:09:34.153Z</updated>
    
    
    
    
    
    <category term="设计" scheme="https://junno_code_blog.gitee.io/junno.gitee.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
    <category term="杂谈" scheme="https://junno_code_blog.gitee.io/junno.gitee.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
</feed>
